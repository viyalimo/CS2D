import socketimport threadingimport pickleimport mathclass Bullet:    def __init__(self, x, y, mx, my):        self.pos = (x, y)        self.blid = -1        self.dir = (mx - x, my - y)        length = math.hypot(*self.dir)        if length == 0.0:            self.dir = (0, -1)        else:            self.dir = (self.dir[0] / length, self.dir[1] / length)        self.angle = math.degrees(math.atan2(-self.dir[1], self.dir[0]))        # self.bullet = pygame.Surface([7, 2]).convert_alpha()        # self.bullet.fill([255, 255, 255])        # self.bullet = pygame.transform.rotate(self.bullet, angle)        self.speed = 30    def update(self):        self.pos = (self.pos[0] + self.dir[0] * self.speed,                    self.pos[1] + self.dir[1] * self.speed)        # print(self.pos)class Server:    def __init__(self, max_client, host):        self.max_client = max_client        self.host_server = host        self.port = 5555        self.server_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        self.max_size_msg = 2000        self.Locker = threading.Lock()        self.qplayer = 0        print(f'Server Listen at {self.host_server}:{self.port}')        try:            self.server_sock.bind((self.host_server, self.port))        except Exception as e:            print(f"Exception bind: {e}")        self.server_sock.listen(max_client)        self.player_start_pos = ([0, 0, "L", 0], [2715, 2565, 'L', 0])        self.player_data = {}        self.members = []        self.bullets = []        self.qbullets = 0        self.mapa_x = 0        self.mapa_y = 0        self.tile_size = 0        self.bull = []        while True:            conn, addr = self.server_sock.accept()            threading.Thread(target=self.Listen, args=(conn, addr)).start()            print(threading.enumerate())    def Listen(self, conn, addr):        try:            while True:                msg = pickle.loads(conn.recv(self.max_size_msg))                # print('msg', msg)                client_id = addr[1]                if client_id not in self.members:                    self.members.append(client_id)                    self.qplayer = len(self.members)                    print(self.members)                if msg[0] == 'CONNECT':                    self.connect(msg, conn, client_id)                elif msg == 'Disconect':                    self.Disconnect(conn, client_id)                else:                    self.Sent(msg, conn, client_id)        except Exception as e:            print(f'ERROR LISTEN: {e}')    def Sent(self, msg, conn, client_id):        #try:            self.coordinate_True(msg, client_id)            self.bullet(client_id)            for i in self.bullets:                self.bull.append([i.pos, i.angle])            self.collision('bul')            for member in self.members:                if member == client_id:                    if self.qplayer == 1:                        conn.send(pickle.dumps((self.player_data.get(client_id), None, self.qplayer, self.bull)))                        self.bull.clear()                    continue                else:                    conn.send(pickle.dumps((self.player_data.get(client_id), self.player_data[member], self.qplayer, self.bull)))                    self.bull.clear()                    continue            # print(self.bullets, self.bull)        #except Exception as e:            #print(f'ERROR SEND: {e}')    def connect(self, msg, conn, client_id):        #try:            print('connect', self.qplayer)            if self.qplayer == 1:                # print('1 player')                conn.send(pickle.dumps((self.player_start_pos[0], 'None', self.qplayer)))                self.player_data[client_id] = self.player_start_pos[0], []                print(self.player_data.get(client_id)[0], self.player_data.get(client_id)[1])                self.mapa_x = msg[1]                self.mapa_y = msg[2]                self.tile_size = msg[3]            if self.qplayer == 2:                for member in self.members:                    if member == client_id:                        continue                    else:                        conn.send(pickle.dumps((self.player_start_pos[1], self.player_data[member], self.qplayer)))                        self.player_data[client_id] = self.player_start_pos[1], []                        continue        #except Exception as e:           # print(f'ERROR CONNECT: {e}')    def Disconnect(self, conn, client_id):        try:            print(client_id, 'покинул игру')            self.members.pop(self.members.index(client_id))            del self.player_data[client_id]            self.qplayer = len(self.members)            # print(self.qplayer, self.player_data)        except Exception as e:            print(f'ERROR DISCONNECT: {e}')    def coordinate_True(self, msg, client_id):        # print(self.player_data.get(client_id), "do")        if self.player_data.get(client_id)[0][0] + 15 == msg[0]:            self.player_data.get(client_id)[0][0] = msg[0]        elif self.player_data.get(client_id)[0][0] - 15 == msg[0]:            self.player_data.get(client_id)[0][0] = msg[0]        elif self.player_data.get(client_id)[0][0] == msg[0]:            self.player_data.get(client_id)[0][0] = msg[0]        else:            # print('naeb po x')            if self.player_data.get(client_id)[0][0] < msg[0]:                self.player_data.get(client_id)[0][0] += 15            else:                self.player_data.get(client_id)[0][0] -= 15        if self.player_data.get(client_id)[0][1] + 15 == msg[1]:            self.player_data.get(client_id)[0][1] = msg[1]        elif self.player_data.get(client_id)[0][1] - 15 == msg[1]:            self.player_data.get(client_id)[0][1] = msg[1]        elif self.player_data.get(client_id)[0][1] == msg[1]:            self.player_data.get(client_id)[0][1] = msg[1]        else:            # print('naeb po y')            if self.player_data.get(client_id)[0][1] < msg[1]:                self.player_data.get(client_id)[0][1] += 15            else:                self.player_data.get(client_id)[0][1] -= 15        self.player_data.get(client_id)[0][2] = msg[2]        self.player_data.get(client_id)[0][3] = msg[3]        # print(self.player_data[client_id], len(msg[4]), "playerrrrrrrrrrrrrrr")        if len(msg[4]) != 0:            for i in msg[4]:                self.player_data.get(client_id)[1].append(i)        # print(self.player_data.get(client_id), "posle")    def collision(self, inf):        if inf == 'bul':            bul_len = len(self.bull)            for i in range(bul_len):                if bul_len > 0 and i < bul_len:                    bul_pos = self.bull[i][0]                    if (bul_pos[0] < self.tile_size or bul_pos[0] > self.mapa_x - self.tile_size) or (bul_pos[1] < self.tile_size or bul_pos[1] > self.mapa_x -self.tile_size):                        if bul_len > 0 and i < bul_len:                            self.bull.pop(i)                            self.bullets.pop(i)                            bul_len -= 1    def bullet(self, client_id):        list_1 = []        list_2 = []        list_3 = []        # print('')        for i in self.members:            # print(self.player_data[i][1][0], 'player_data SERVER')            if i == client_id:                if len(self.player_data[i][1]) == 0:                    list_1 = []                    # print(f'1: list1 = {list_1}')                else:                    print(self.player_data[i][1][0], 'player_data SERVER')                    bul = Bullet(*self.player_data[i][1][0])                    list_1.append(bul)                    bul = None                    # print(f'2: list1 = {list_1}')                if len(list_1) != 0 or len(list_2) != 0:                    list_3 = [list_1 + list_2]                    # print(f'3: list3 = {list_3}')                self.player_data[client_id][1].clear()                continue            else:                if len(self.player_data[i][1]) == 0:                    list_2 = []                    # print(f'4: list2 = {list_2}')                else:                    bul = Bullet(*self.player_data[i][1][0])                    list_2.append(bul)                    bul = None                    # print(f'5: list1 = {list_2}')                if len(list_1) != 0 or len(list_2) != 0:                    list_3 = [list_1 + list_2]                    # print(f'6: list1 = {list_3}')                self.player_data[i][1].clear()                continue        for bullets_data in list_3:            self.bullets.extend(bullets_data)        for bullet in self.bullets[:]:            bullet.update()